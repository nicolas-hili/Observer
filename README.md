# Observer
The Observer is a versatile library implemented in C++ to add obsersability and steering capabilities to any soft-real time system generated from a UML-RT model created in the Papyrus-RT tool. It supports the following features:

- Observation of the execution of soft real-time systems modelled in UML-RT through Model-to-Model (M2M) transformations (using Epsilon)
- Execution steering
- Trace generation with customizable format of traces
- Possibility to connect multiple monitors seamlessly
- Traces can be transmit to monitors on-the-fly or periodically
- Various formats of communication supported (TCP/IP, Shared Memory, MQTT, ...)
- Various formats of serialization supported (Text, XML, ...)
- Easily extensible to add new formats of communication/serialization
- Instrumentation of a system can be done manually or automatically through Graphical User interface (GUI) available
- Adaptable to UML models with minor changes to the Observer library
- Adaptable to non-modelled systems (C++ library used in standalone)

# Table of Contents
1. [Basic Set-up](#setup)
2. [Installation](#installation)
3. [Getting Started](#getting-started)
4. [Advanced Configuration](#advanced-config)
5. [List of Available Add-ons](#addons)
6. [Creating New Add-ons](#new-addons)
7. [Extending the Observer](#extending)
8. [Using the Observer library for (Non-Modelling) Standalone Projects (C++)](#standalone)
9. [Updating the Observer](#updating)

<a name="setup"></a>
# Basic Set-up 

Prior any use, a working version of [Papyrus-RT 1.0 user version](https://www.eclipse.org/papyrus-rt/content/download.php#RCP) along with [Epsilon 1.6 (Interim)](https://www.eclipse.org/epsilon/download/) must be installed.

> **Note: **Papyrus-RT 1.0 user version only works with Java 8 64-bit. If you are running Ubuntu and have a more recent version of Java installed, you can install Java 8 along with your current Java version using the following commands: 
`$ sudo apt-get install openjdk-8-jre -y`{:.bash} followed by `$ sudo update-alternatives --config java`{:.bash}

To install Epsilon, proceed the following steps:

 * Open Papyrus-RT
 * Add the following update site: `http://download.eclipse.org/epsilon/interim/`
 * Select the Epsilon Interim update site and install all features of the three categories: *Epsilon Core*, *EMF integration*, and *UML integration*
 * Complete the installation and restart Papyrus-RT
 
 <a name="installation"></a>
# Installation

Installing the Observer library can be done using two methods:

* Automatically by using the Observer Eclipse update site
* Manually by importing the Observer plugins onto your Eclipse Workspace

## Method 1: Using The Observer Update Site 
 * If not already done, open Papyrus-RT
 * Add the following update site: `http://mase.cs.queensu.ca/observer`
 * Select the Observer update site using the *Work with* field
 * Click on *Select All* to select all features of the three categories
 * Complete the installation and restart Papyrus-RT
  
> **Note:** It is not mandatory to install all communication and serialization add-ons, but at least one of each category must be installed in order to be able to generate code. For example, for using only TCP/IP communication and text serialization, you have to select `Observer feature`, `TCP/IP Socket Support Add-on`, and `Text Support Add-on Feature`.
 
 
## Method 2: Manually Importing the Plug-ins into the Workspace

The Git repository is structured into the following directories:

* **Observer/**  Contains the core plug-ins used by the Observer along with its add-ons
* **Models/** Contains models to which the Observer can be applied
* **Monitors/** Contains code examples for monitoring the observed models
* **Development/** Contains development code. This is only useful if you plan to create your own custom version of the Observer
* **experiments/** Some experiments we made
* **Features/** Contains the different Eclipse features and update site

If not already done, open Papyrus-RT. You can now manually import the Observer plug-ins in your Workspace. At least the following plug-ins must be retrieved from the git repository:
 
 *  `ca.queensu.cs.observer`:Contains the Observer UML library
 *  `ca.queensu.cs.observer.method.socket`: TCP/IP communication support
 * `ca.queensu.cs.observer.serializer.text`: Add-on to serialize events generated by the Observer in pure text format.
 * `ca.queensu.cs.observer.ui`: Contains the Epsilon EOL transformation rules used to instrument a UML-RT model


> **Note:** As for the previous method, feel free to import the other plug-ins to add alternative communication and serialization capabilities.

<!-- you can use any serialization and communication methods from the `Observer/addons/` directory instead of `ca.queensu.cs.observer.method.socket` and `ca.queensu.cs.observer.serializer.text`. -->

<a name="getting-started"></a>
# Getting Started

The following section will guide you through the process of generating observable code and executing your system along with monitors to observe its execution.

It is decomposed into the following steps:

 1. Generate observable code
 2. Compile and execute the system
 3. Observer the system execution
 4. Steer the system execution
 
 In the following, we assume that you installed the TCP/IP add-on along with the text serialization format. For this tutorial, we will use the model located under `Models/ParcelRouter` of the Git repository.

## Step 1: Generate Observable Code

As for the installation, two methods are possible to generate observable code:
 * The quickest method is through the Graphical User Interface (GUI)
 * The other method is through an Epsilon EOL Program Configuration

### Method a) Using the Graphical User Interface (GUI)

The quickest method to use the Observer to generate Observable code is using the Graphical User Interface (GUI) provided with the Observer library.

* Import the model located under `Models/ParcelRouter` in your workspace
* Open the model (in the *Project Explorer* view, open `ParcelRouter/model`). A Papyrus graphical editor will be opened
 * (optional) In the *Model Explorer* view, right-click on *RootElement* and under *Observer*, select the communication method and serialization format you want to use
 * In the *Model Explorer* view, right-click on *RootElement* and select *Generate Observable Code*

> **Note:** A common mistake is to confuse the *Model Explorer* view with the *Project Explorer* view. Make sure your perform the two last steps in the *Model Explorer* view and not in the *Project Explorer* view. The *Model Explorer* view should be located below the *Project Explorer* view. If you do not see it, make you you have the Papryus perspective opened. If you still do not see it, restart the Papyrus perspective by right-clicking on the Papyrus icon on the top right corner, then choose *Reset*.

A modal window will open when the instrumented code of the system is generated. The source code is located under a newly created project named `ParcelRouter_CDTProject` under a *src* folder.

### Method b) Using an Epsilon EOL Program Configuration (Manual Configuration)

 * Import the model located under `Models/ParcelRouter` in your workspace
 * Create an Epsilon EOL Target Configuration :
 *  Select *Run/Run Configurations*
 *  Double-click on *EOL Program* to create a new configuration
 *  In the *Source* tab, browse to select `/ca.queensu.cs.observer.ui/EOLScripts/UMLRTObserverInstrumentation.eol`
 *  In the *Model* tab, add a new Epsilon Model by clicking on *Add*, then:
 *  * Select *UML Model*. If you do not see this option, it is likely that you have not installed the *Epsilon UML Integration* feature ;
 *  * Set the values of both *Name* and *Aliases* to *UMLRTModel* ;
 *  * For the *Model file* field, browse to select `/ParcelRouter/model.uml` ;
 *  * Leave all other fields as set by default ;
 *  In the *Parameters* tab, create the three following variables:
 *  * name = "observerPath", type = "String", value = "platform:/resources/ca.queensu.cs.observer/libraries/observer.uml"
 *  * name = "method", type = "String", value = "&lt;PATH_TO_GIT_REPOSITORY&gt;/Observer/addons/methods/ca.queensu.cs.observer.method.socket/cpplib"
 *  * name = "serializer", type = "String", value = "&lt;PATH_TO_GIT_REPOSITORY&gt;/Observer/addons/serializers/ca.queensu.cs.observer.serializer.text/cpplib"
 *  Hit *Run*

The Eclipse console should output the following content:

    Number of capsules: 8
    Number of states: 14
    
    --
    Start (re-)building
    -> Load observer
    -> Add the Observer capsule part
    Done.
    
    -> Add the serializer artifact
    Done.
    
    -> Add the method artifact
    Done.
    
    -> Instrumentation of capsule: Sensor
    -> Instrumentation of capsule: Switcher
    -> Instrumentation of capsule: Bin
    -> Instrumentation of capsule: Chute
    -> Instrumentation of capsule: Gen
    -> Instrumentation of the Observer capsule
    Done.
    --

**Notes:**

 * If during set-up you selected other serialization and communication methods, you should reflect it when setting the Epsilon variables in the *Parameters* tab ;
 * The *observerPath* variable is an Eclipse-compliant URI that can be defined following an available URI scheme:
 *  * The `file:/` URI scheme is used to refer to absolute files on your Hard drive
 *  * The `platform:/resources/plugin-name` URI scheme is used to refer to a plug-in imported in you Eclipse workspace
 *  * &lt;PATH_TO_GIT_REPOSITORY&gt; should be replaced with the absolute path containing your Git repository


### Step 2: Compile and Execute the System

You should now have a project called *ParcelRouter_CDTProject* created in you workspace.

 * Open a terminal and navigate into `ParcelRouter_CDTProject/src`
 * Compile the program: `$ make`
 * Execute the code: `$ ./Parcel_RouterMain`

At this point, the Parcel Router executes in a loop and routes parcels randomly generated to some bins based on the parcels' tags. What actually the instrumented program is doing, it:

 1. Creates a TCP/IP server with a default port set to `8080` (if you selected the socket communication method) ;
 2. Registers all capsules of the system. This action is used for steering the model (see below) ;
 3. For each event generated by the model, an Observer capsule added to the model will forward it to any external monitoring tools supporting TCP/IP and listening to the port`8080`

### Step 3: Observe the System Execution

To retrieve the events generated by the Observer capsule (and to test that everything works by the same occasion), you can create a TCP/IP client connecting to port `8080`. Alongwith the implementation of the Observer, we provide two monitors:

 * ParcelRouterAnimation: a GTK animation animating the execution of the Parcel Router system through the Observer capsule
 * TCPClient: a simple TCP/IP client to read from and write into TCP/IP socket communication.
 
Both monitors are located under the `Monitors` directory. For Step 3, we only focus on the *ParcelRouterAnimation* plug-in

 * If not already done, import the *ParcelRouterAnimation* plug-in into your workspace.
 * From the *Project Explorer*, right-click on the *ParcelRouterAnimation* plug-in and select *Run As/Java Application*
 * If you have stopped the execution of the *Parcel Router* system from Step 2, relaunch it: `$ ./Parcel_RouterMain`

### Step 4: Steer the System Execution

[TBD]

<a name="advanced-config"></a>
# Advanced Configuration

Advanced configuration can be passed to the Observer through the creation of a `config` file located at the root of the binary obtained from Step 2 above. A sample of the file is given below:

	# Main configuration
	
	# Remove the two lines below if you want to receive traces instantaneously
	periodicity=1000 # 1000 microseconds
	mode=periodic
	
	# Configuration per Add-ons
	[text]
	  keyValueSeparator=: # a semi-colon is used as separator between the key name and the value for each field
	  format=eventId|sourceName|eventSource|eventKind|seconds|nanoseconds|params # filter the fields to generate
	  paramSeparator=; # separators between parameters. It has no effect when the "params" field is not included in the format option
	  separator=| # separator between fields
	
	[socket]
	  Port=8080 # listen on port 8080
	
	# ...

## Configuring the Add-ons using the GUI (beta)

Configuration pages are generated for each add-on to be able to configure the add-on in the GUI and to generate the corresponding `config` file.

 * If not already done, open Papyrus-RT
 * In the top menubar, open `Window/Preferences`
 * Under `Papyrus-RT/Observer`, open the subpreference page corresponding to the Add-on you want to configure
 * Configure the different options of the add-on. A preview of the config file is displayed on-the-fly
 
 **Known limitations**
 
 *  The subpreference pages may not appear. In that case, you have to explicitely open the `Papyrus-RT/Observer` preference page, even though this one is empty
 * The corresponding `config` is not generated for now (TODO). It must be manually created.
 * It is not possible to configure the main options of the Observer (*mode* and *periodicity*) for now (TODO)
 

<a name="addons"></a>
# List of Available Add-ons

This section lists the different add-ons that adds serialization and communication capabilities to the Observer

## Serializers

### Text

Basic serialization in text. Support custom formats and custom separators.

| Name               | Description                                                                                | Format    | Default value                                                       |
|--------------------|--------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------|
| separator          | character separator between fields                                                         | Character | |                                                                   |
| format             | format of the trace events                                                                 | String    | eventId|sourceName|eventSource|eventKind|seconds|nanoseconds|params |
| keyValueSeparator  | character separator between the key and value of each field                                | Character | :                                                                   |
| parameterSeparator | Character separator between parameters (has no effect if format does not contain "params") | Character | ;                                                                   |

### XML

(To document)

### JSON

(To document)

### CTF

(To document)

## Communication Method

### TCP/IP

TCP/IP communication support. The modelled system plays the role of master and can accept multiple clients to connect. Its only configuration is the port to establish the TCP/IP communication.

| Name               | Description                                                                                | Format    | Default value                                                       |
|--------------------|--------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------|
| port          | Port of the TCP/IP communication                                                         | Integer | 8080  |


### MQTT

MQTT communication support.

| Name               | Description                                                                                | Format    | Default value                                                       |
|--------------------|--------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------|
| port          | Port of the MQTT communication                                                         | Integer | 1883 |
| address          | Adress of the MQTT broker                                                         | String | mqtt.jahed.ca |
| username          | Username for normal autentication                                                         | String |  |
| password          | Password for normal autentication                                                         | String |  |
| subTopic          | Subscribe topic                                                         | String | observer_out |
| pubTopic          | Publish topic                                                         | String | observer_in |



### Shared Memory

Shared memory communication support.

| Name               | Description                                                                                | Format    | Default value                                                       |
|--------------------|--------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------|
| name          | Area name                                                        | String | EventArea |
| qName          | Queue name                                                         | String | EventQ |
| withLock          | Whether a lock is used                                                         | Boolean | true |
| size          | Size of the queue                                                        | Integer |  9999999 |
| mode          | Subscribe topic                                                         | Enumeration | Server |



### StandardIO

Basic IO communication supported via `std::cout` and `std::cin`. Useful for debugging. No configuration is supported.

<a name="new-addons"></a>
# Creating New Add-ons

[TODO]

<a name="extending"></a>
# Extending the Observer

The Observer library has been developped from the ground up to be easily extended, whether you want to to support specific events or to support other UML-based languages. This section gives some advices for extending the Observer library.

## Structure of the Observer C++ library

The Observer library is located under the `ca.queensu.cs.observer.cpp` C++ project. The `src` directory contains the following source files:
 * **Config.cc**: used to parse `config` files
 * **Event.cc**: contains the "meta-model" of an event
 * **Method.cc**: interface used to implement communication method add-ons
 * **Serializer.cc**: interface used to implement serializer add-ons.
 * **Observer.cc**: a main class to use the Observer in a standalone C++ program
 * **ObserverTest.cc**: a class test to test the Observer
 
## Testing the Observer

A Makefile is provided for testing the Observer library. Simply open a terminal and locate the `ca.queensu.cs.observer.cpp` directory, then type: `$ make`

By default, the Observer will use the text serializer and TCP/IP (socket) communication method. Those can be overriden in the `config.mk` file.

## Modifying the Structure of the Event Class

Some of the fields of the Event class are specific to UML-RT while others are more generic and can be used for other UML-based systems. You may want to change the structure of the Event class if:

* You want to use the Observer library for UML-RT models, but you need to add new fields to address specific concerns (e.g., power consumption)
* You want to use the Observer library outside of UML-RT and you want to get rid of some fields that are specific to UML-RT (e.g., capsule, capsule instance)

The majority of the changes you would have to do are located in the `Event.hh` and `Event.cc` files. Modifying the files may lead to incompatibility with existing add-ons.

Upon the addition or the removal of some fields, the `setField()` and `getField()` functions must be updated. They are responsible for setting/getting the fields in a text format, so that serializers can used the fields agnostically of their original types.

> **Important Note:** Change performed to the Observer C++ library are not automatically reflected to the UML-RT library used by Papyrus-RT. TO reflect those change, you must update the UML-RT model of the Observer located under `ca.queensu.cs.observer/libraries`. This can be done automatically thanks to an updated that is available under the `Development` directory of the repository. See [this section](#updating).

## Modifying the Generation of Events

Epsilon EOL is responsible for transforming a UML-RT model of a system into an observer version of the same model so as to support the observation and the steering of the system execution.

If you want to change the supported taxonomy of events generated by the Observer capsule, you need to update the EOL transformation rules. Those rules are located under `ca.queensu.cs.observer.ui/EOLScripts`. The entry point of the rules is located in the file named `UMLRTObserverInstrumentation.eol`.

<a name="standalone"></a>
# Using the Observer library for (Non-Modelling) Standalone Projects (C++)

The Observer library being written in C++, you can choose to use it outside of Papyrus-RT. It can be used for any C++ projects requiring observation capabilities. You can also use it with any modelling languages that outputs C++ code for a modelled system.

<a name="updating"></a>
# Updating the Observer

If you plan to make some changes to the Observer C++ library, those changes are not reflected on the Observer library. To do it, yo have to proceed the following steps:

[TODO]
