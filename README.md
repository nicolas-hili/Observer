# Observer
The Observer is a versatile library to add obsersability and steering capabilities to any system generated from a UML-RT model created in the Papyrus-RT tool.

# Basic Set-up

 * Install a Working version of Papyrus-RT 1.0 user version
 * Install Epsilon Core, EMF integration, and UML integration through the Epsilon stable update site
 * Import inside your running version of Papyrus-RT at least the following plug-ins from the git repository
 *  * `ca.queensu.cs.observer`:Contains the Observer UML library
 *  * `ca.queensu.cs.observer.method.socket`: TCP/IP communication support
 *  * `ca.queensu.cs.observer.serializer.text`: Add-on to serialize events generated by the Observer in pure text format.
 *  * `ca.queensu.cs.observer.ui`: Contains the Epsilon EOL transformation rules used to instrument a UML-RT model

<u>Note:</u> you can use any serialization and communication methods from the `Observer/addons/` directory instead of `ca.queensu.cs.observer.method.socket` and `ca.queensu.cs.observer.serializer.text`.

# Getting Started

## Manually: Using an Epsilon EOL Program Configuration

In this section we will show a basic usage of the Observer on a UML-RT model produced by Papyrus-RT. For this basic usage, we will use the model located under `Models/ParcelRouter` of the Git repository.

### Step 1: Instrument the UML-RT Model
 * Import the model located under `Models/ParcelRouter` in your workspace
 * Create an Epsilon EOL Target Configuration :
 *  Select *Run/Run Configurations*
 *  Double-click on *EOL Program* to create a new configuration
 *  In the *Source* tab, browse to select `/ca.queensu.cs.observer.ui/EOLScripts/UMLRTObserverInstrumentation.eol`
 *  In the *Model* tab, add a new Epsilon Model by clicking on *Add*, then:
 *  * Select *UML Model*. If you do not see this option, it is likely that you have not installed the *Epsilon UML Integration* feature ;
 *  * Set the values of both *Name* and *Aliases* to *UMLRTModel* ;
 *  * For the *Model file* field, browse to select `/ParcelRouter/model.uml` ;
 *  * Leave all other fields as set by default ;
 *  In the *Parameters* tab, create the three following variables:
 *  * name = "observerPath", type = "String", value = "platform:/resources/ca.queensu.cs.observer/libraries/observer.uml"
 *  * name = "method", type = "String", value = "&lt;PATH_TO_GIT_REPOSITORY&gt;/Observer/addons/methods/ca.queensu.cs.observer.method.socket/cpplib"
 *  * name = "serializer", type = "String", value = "&lt;PATH_TO_GIT_REPOSITORY&gt;/Observer/addons/serializers/ca.queensu.cs.observer.serializer.text/cpplib"
 *  Hit *Run*

The Eclipse console should output the following:

    Number of capsules: 8
    Number of states: 14
    
    --
    Start (re-)building
    -> Load observer
    -> Add the Observer capsule part
    Done.
    
    -> Add the serializer artifact
    Done.
    
    -> Add the method artifact
    Done.
    
    -> Instrumentation of capsule: Sensor
    -> Instrumentation of capsule: Switcher
    -> Instrumentation of capsule: Bin
    -> Instrumentation of capsule: Chute
    -> Instrumentation of capsule: Gen
    -> Instrumentation of the Observer capsule
    Done.
    --

<u>Notes:</u>

 * If during set-up you selected other serialization and communication methods, you should reflect it when setting the Epsilon variables in the *Parameters* tab ;
 * The *observerPath* variable is an Eclipse-compliant URI that can be defined following an available URI scheme:
 *  * The `file:/` URI scheme is used to refer to absolute files on your Hard drive
 *  * The `platform:/resources/plugin-name` URI scheme is used to refer to a plug-in imported in you Eclipse workspace
 *  * &lt;PATH_TO_GIT_REPOSITORY&gt; should be replaced with the absolute path containing your Git repository

### Step 2: Generate Code from the Instrumented Model
Once the Model is instrumented, the next step is to generate code and to build the system:

 * Open the *Parcel Router* model in Papyrus-RT by clicking on *model* from the *Project Explorer*
 * Using the *Model Explorer*, click on the root element (called *Root Element*) and select *(Re)Generate (all) Code*

<u>Note:</u> The *Model Explorer* view should be located below the *Project Explorer* view. If you do not see it, make you you have the Papryus perspective opened. If you still do not see it, restart the Papyrus perspective by right-clicking on the Papyrus icon on the top right corner, then choose *Reset*.

### Step 3: Compile and Execute the System

You should now have a project called *ParcelRouter_CDTProject* created in you workspace.

 * Open a terminal and navigate into `ParcelRouter_CDTProject/src`
 * Compile the program: `$ make`
 * Execute the code: `$ ./Parcel_RouterMain`

At this point, the Parcel Router executes in a loop and routes parcels randomly generated to some bins based on the parcels' tags. What actually the instrumented program is:

 1. Create a TCP/IP server with a default port set to `8080` (if you selected the socket communication method) ;
 2. Register all capsules of the system. This action is used for steering the model (see below) ;
 3. For each event generated by the model, an Observer capsule added to the model will forward it to any external monitoring tools supporting TCP/IP and listening to `http://localhost:8080`

### Step 4: Observe the System Execution

To retrieve the events generated by the Observer capsule (and to test that everything works by the same occasion), you can create a TCP/IP client connecting to `http://localhost:8080`. Alongwith the implementation of the Observer, we provide two monitors:

 * ParcelRouterAnimation: a GTK animation animating the execution of the Parcel Router system through the Observer capsule
 * TCPClient: a simple TCP/IP client to read from and write into TCP/IP socket communication.
 
Both monitors are located under the `Monitors` directory. For Step 4, we only focus on the *ParcelRouterAnimation* plug-in

 * If not already done, import the *ParcelRouterAnimation* plug-in into your workspace.
 * From the *Project Explorer*, right-click on the *ParcelRouterAnimation* plug-in and select *Run As/Java Application*
 * If you have stopped the execution of the *Parcel Router* system from Step 3, relaunch it: `$ ./Parcel_RouterMain`

### Step 5: Steer the System Execution

[TBD]

## Graphically: Using a GUI

[TBD]

# Advanced Configurations

[TBD]

# List of Available Add-ons

This section lists the different add-ons that adds serialization and communication capabilities to the Observer

## Serializers
* 
## Communication Method
