<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Package xmi:id="_rqPoENRIEeayFZJ-SYgDzA" name="Observation">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_pg8AwBYIEee3LJqEo64_Eg" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_pg918BYIEee3LJqEo64_Eg" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Package" xmi:id="_TIQtwNRNEearFdKvR_8nWw" name="Observation">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_TIMcUNRNEearFdKvR_8nWw" name="Observation">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_TIVmQNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TITxENRNEearFdKvR_8nWw" contract="_TITxENRNEearFdKvR_8nWw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_TIeJINRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIbF0NRNEearFdKvR_8nWw" contract="_TIbF0NRNEearFdKvR_8nWw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TITxENRNEearFdKvR_8nWw" name="Observation"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TIW0YNRNEearFdKvR_8nWw" name="Observation~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_di784NRNEearFdKvR_8nWw" name="event">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_XIa7ENROEearFdKvR_8nWw" name="data" type="_hltsEFzUEeevlLbSf8F1Eg"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_TIZ3sNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIW0YNRNEearFdKvR_8nWw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_TIaewNRNEearFdKvR_8nWw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TIbF0NRNEearFdKvR_8nWw" name="ObservationIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_TIewMNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIbF0NRNEearFdKvR_8nWw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_eIzqENRNEearFdKvR_8nWw" operation="_di784NRNEearFdKvR_8nWw"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_7RXxINRMEearFdKvR_8nWw" name="Observer" classifierBehavior="_JWCwUNROEearFdKvR_8nWw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_kLF8oNRNEearFdKvR_8nWw" name="observation" visibility="public" type="_TIMcUNRNEearFdKvR_8nWw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_xnxB8N21EeakB9CQglrL_g" value="20"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_xntXkN21EeakB9CQglrL_g" value="20"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_7_KOwNRNEearFdKvR_8nWw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_JX_00NhDEeaqev0ObzxoAQ" name="commandTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_v6JnQH3fEeeLa6HXnixBwQ" name="eventQueue" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_3fw4UH3gEeeLa6HXnixBwQ" name="eventTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_xfMiYH3zEeeLa6HXnixBwQ" name="isPeriodic">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_7UrZwH3zEeeLa6HXnixBwQ"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_JWCwUNROEearFdKvR_8nWw" name="ObserverStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_JWHo0NROEearFdKvR_8nWw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_JWPkoNROEearFdKvR_8nWw" name="configure" source="_JWJeANROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2mliENgzEeaqev0ObzxoAQ">
              <language>C++</language>
              <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new MethodImpl();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new SerializerImpl();
this->serializer->configure(config.getConfigList());

std::string mode = config.get(&quot;mode&quot;);
std::string periodicity = config.get(&quot;periodicity&quot;);

// If sending events is set as periodic
if (periodicity != &quot;&quot; &amp;&amp; mode == &quot;periodic&quot;) {
	this->isPeriodic = true;
	// Periodicity is set in microseconds
	// Multiplied by 1000 to get nanoseconds
	long nano = (long long)(atol(periodicity.c_str())*1000);
	long seconds = nano/1000000000;
	eventTimer.informEvery(UMLRTTimespec(seconds, (nano-1000000000*seconds)));
}

// Instantiating the command timer
commandTimer.informEvery(UMLRTTimespec(0,500000000));
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_RFMNUNROEearFdKvR_8nWw" name="event received" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_elYb4NROEearFdKvR_8nWw">
              <language>C++</language>
              <body>std::string event = this->serializer->serialize(data.event) + &quot;\n&quot;;
if (this->isPeriodic) {
	eventQueue.push_back(event);
}
else {
	this->method->sendData(event);
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_Ur9fsNROEearFdKvR_8nWw" event="_eIzqENRNEearFdKvR_8nWw" port="_kLF8oNRNEearFdKvR_8nWw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_AIf_YNhDEeaqev0ObzxoAQ" name="command received" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WYUQgNhDEeaqev0ObzxoAQ">
              <language>C++</language>
              <body>std::string data = this->method->readData();
    if (data != &quot;&quot;) {
    Event evt = this->serializer->parse(data);
    if (evt.getEventSource() == Event::EventSource::Command) {

      std::map&lt;std::string, size_t>::iterator iter;
      std::string sourceName = evt.getSourceName();

      switch(evt.getEventKind()) {
        case Event::EventKind::List:
          // List of capsule parts
          evt.setSourceName(&quot;Observer&quot;);
          for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
            evt.setParam(iter->first, capsuleTypes[iter->first]);
          }
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Show:
          // Show a specific capsule part
          this->method->sendData(this->serializer->serialize(listCapsuleMessage(evt)));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Trigger:
          evt = this->triggerCapsuleMessage(evt);
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        default:
        break;
      }
    }
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_ZnQ4wNhDEeaqev0ObzxoAQ" port="_JX_00NhDEeaqev0ObzxoAQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_rCO0YBYIEee3LJqEo64_Eg" name="register capsules" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_zp5NwBYIEee3LJqEo64_Eg">
              <language>C++</language>
              <body>std::stringstream ss;
ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
printf(&quot;capsule name: %s at port %d\n&quot;, ss.str().c_str(), (int)msg->sapIndex0_);
capsules[ss.str()] = msg->sapIndex0_;
capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_syzaIBYIEee3LJqEo64_Eg" port="_kLF8oNRNEearFdKvR_8nWw">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WIZHIH3kEeeLa6HXnixBwQ" name="events periodically sent" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fsEc0H3kEeeLa6HXnixBwQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>unsigned size = this->eventQueue.size();
for (unsigned int i = 0; i &lt; size; i++) {
	this->method->sendData(this->eventQueue.back());
	this->eventQueue.pop_back();
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WhnfcH3kEeeLa6HXnixBwQ" port="_3fw4UH3gEeeLa6HXnixBwQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_JWJeANROEearFdKvR_8nWw">
            <name xsi:nil="true"/>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_JWMhUNROEearFdKvR_8nWw" name="OBSERVING"/>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_E2OD0KMgEeiNcrjkKG4ksw" name="listCapsuleMessage" specification="_h6x0oKMfEeiNcrjkKG4ksw">
        <language>C++</language>
        <body>/*
 * Return the list of capsule message
 * Below is an example
 * Overriden by the model instrumentation.
std::string sourceName = evt.getSourceName();
if (sourceName == &quot;Gen&quot;) {
        evt.setParam(&quot;1&quot;, &quot;timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;generate&quot;);
}
else if (...) {
}

*/
return evt;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_uC5ZYKOVEeiGGIWOIACepw" name="triggerCapsuleMessage" specification="_isFSIKOVEeiGGIWOIACepw">
        <language>C++</language>
        <body>return evt;

/*  
 * The code below is an example of what to generate
std::map&lt;std::string, size_t>::iterator iter;
  std::string instanceName = evt.getCapsuleInstance(); // name of the instance
  std::string capsuleType = &quot;&quot;;     // name of the capsule
  std::string opName    = evt.getParam(&quot;operation&quot;);
  int portIndex = -1;

  for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
    if (iter->first == instanceName) {
      portIndex = capsules[iter->first];
      capsuleType = capsuleTypes[iter->first];
      break;
    }
  }

// For debugging purpose
//  printf(&quot;instanceName = %s, capsuleType = %s, portIndex = %d\n&quot;, 
//      instanceName.c_str(),
//      capsuleType.c_str(),
//      (int)portIndex);

  if (portIndex == -1) {
    printf(&quot;Problem with instanceName = %s\n&quot;, instanceName.c_str());
    evt.setParam(&quot;success&quot;, 0);
    return evt;
  }

  if (capsuleType == &quot;Gen&quot;) {
    if (opName == &quot;timer_timeout&quot;) {
      observation.Gen_timer_timeout().sendAt(portIndex);
      evt.setParam(&quot;success&quot;, 1);
    }
  }
  if (capsuleType == &quot;Chute&quot;) {
    if (opName == &quot;enter_transmit&quot;) {
      observation.Chute_enter_transmit(this->parcel).sendAt(portIndex);
      evt.setParam(&quot;success&quot;, 1);
    }
  }

  evt.setParam(&quot;success&quot;, 0);
  return evt; */</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7A2QAKO1EeiDysg9bce8IQ" name="to_bool" specification="_nMJWcKO1EeiDysg9bce8IQ">
        <language>C++</language>
        <body>return strcmp(s.c_str(),&quot;0&quot;) != 0 &amp;&amp; strcmp(s.c_str(), &quot;false&quot;) != 0;</body>
      </ownedBehavior>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_h6x0oKMfEeiNcrjkKG4ksw" name="listCapsuleMessage" concurrency="guarded" method="_E2OD0KMgEeiNcrjkKG4ksw">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_vc584KMfEeiNcrjkKG4ksw" name="evt">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_9bpvsKMfEeiNcrjkKG4ksw" name="response" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_isFSIKOVEeiGGIWOIACepw" name="triggerCapsuleMessage" concurrency="guarded" method="_uC5ZYKOVEeiGGIWOIACepw">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_ks8WoKOVEeiGGIWOIACepw" name="evt">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_ktDrYKOVEeiGGIWOIACepw" name="response" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_nMJWcKO1EeiDysg9bce8IQ" name="to_bool" concurrency="guarded" method="_7A2QAKO1EeiDysg9bce8IQ">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_x7X5QKO1EeiDysg9bce8IQ" name="s">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_3A5BkKO1EeiDysg9bce8IQ" name="result" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_YqQ6AN2eEeakB9CQglrL_g" name="internal">
      <packagedElement xmi:type="uml:Artifact" xmi:id="_8GqbkNMAEemGc_rPAcwCKA" name="Event"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_8JDoQNMAEemGc_rPAcwCKA" name="Method"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_8JEPUNMAEemGc_rPAcwCKA" name="Config"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_8JE2YNMAEemGc_rPAcwCKA" name="Serializer"/>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_PUZk4FSTEemSbvLi_UYxQQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_PUdPQFSTEemSbvLi_UYxQQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_TIvqIFScEemmpvdrl88cHg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_TIzUgFScEemmpvdrl88cHg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_5gsuEF1QEemYMutb7hxLzQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_5gvxYF1QEemYMutb7hxLzQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_9TYoQNJOEemyz6RV9O60rA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_9ThyMNJOEemyz6RV9O60rA" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_siuzoNMAEemh7LX63Jn4Vg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_sixP4NMAEemh7LX63Jn4Vg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_8GljENMAEemGc_rPAcwCKA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_8Gn_UNMAEemGc_rPAcwCKA" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_hltsEFzUEeevlLbSf8F1Eg" name="EventObj"/>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_rqpQsNRIEeayFZJ-SYgDzA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_rqrF4NRIEeayFZJ-SYgDzA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_-yPMoNRIEearFdKvR_8nWw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_-ygSYNRIEearFdKvR_8nWw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_-y8-UNRIEearFdKvR_8nWw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_-y9lYNRIEearFdKvR_8nWw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_30kJAH3zEeeLa6HXnixBwQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_30kwEH3zEeeLa6HXnixBwQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
    </profileApplication>
  </uml:Package>
  <UMLRealTime:Capsule xmi:id="_7Sjc49RMEearFdKvR_8nWw" base_Class="_7RXxINRMEearFdKvR_8nWw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_TISi8NRNEearFdKvR_8nWw" base_Package="_TIQtwNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIU_MNRNEearFdKvR_8nWw" base_Interface="_TITxENRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIYpkNRNEearFdKvR_8nWw" base_Interface="_TIW0YNRNEearFdKvR_8nWw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIc7ANRNEearFdKvR_8nWw" base_Interface="_TIbF0NRNEearFdKvR_8nWw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_TIfXQNRNEearFdKvR_8nWw" base_Collaboration="_TIMcUNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTPort xmi:id="_kLI_8NRNEearFdKvR_8nWw" isNotification="true" isPublish="true" isWired="false" registration="Automatic" base_Port="_kLF8oNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTPort xmi:id="_7_N5INRNEearFdKvR_8nWw" isWired="false" base_Port="_7_KOwNRNEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_JWL6QNROEearFdKvR_8nWw" base_Pseudostate="_JWJeANROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTState xmi:id="_JWO9kNROEearFdKvR_8nWw" base_State="_JWMhUNROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_JWQLsNROEearFdKvR_8nWw" base_Region="_JWHo0NROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_JXT7oNROEearFdKvR_8nWw" base_StateMachine="_JWCwUNROEearFdKvR_8nWw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_rFjo0NRXEearFdKvR_8nWw" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;MethodImpl.hh&quot;&#xA;#include &quot;SerializerImpl.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" base_Class="_7RXxINRMEearFdKvR_8nWw" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_JYIXsNhDEeaqev0ObzxoAQ" isWired="false" base_Port="_JX_00NhDEeaqev0ObzxoAQ"/>
  <RTCppProperties:CapsuleProperties xmi:id="_kesEUFzUEeevlLbSf8F1Eg" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_hltsEFzUEeevlLbSf8F1Eg" publicDeclarations="Event event;"/>
  <RTCppProperties:AttributeProperties xmi:id="__cG5QH3fEeeLa6HXnixBwQ" type="std::deque&lt;std::string>" base_Property="_v6JnQH3fEeeLa6HXnixBwQ"/>
  <UMLRealTime:RTPort xmi:id="_3gClIH3gEeeLa6HXnixBwQ" isPublish="false" isWired="false" base_Port="_3fw4UH3gEeeLa6HXnixBwQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_loF-cKMgEeiNcrjkKG4ksw" type="Event" base_Parameter="_vc584KMfEeiNcrjkKG4ksw"/>
  <RTCppProperties:ParameterProperties xmi:id="_olPFAKMgEeiNcrjkKG4ksw" type="Event" base_Parameter="_9bpvsKMfEeiNcrjkKG4ksw"/>
  <RTCppProperties:ParameterProperties xmi:id="_ktJyAKOVEeiGGIWOIACepw" type="Event" base_Parameter="_ks8WoKOVEeiGGIWOIACepw"/>
  <RTCppProperties:ParameterProperties xmi:id="_ktSU4KOVEeiGGIWOIACepw" type="Event" base_Parameter="_ktDrYKOVEeiGGIWOIACepw"/>
  <RTCppProperties:ParameterProperties xmi:id="_M9DZEKPFEeizIuv3spzswQ" type="std::string" base_Parameter="_x7X5QKO1EeiDysg9bce8IQ"/>
  <RTCppProperties:ArtifactProperties xmi:id="_8I_W0NMAEemGc_rPAcwCKA" base_Artifact="_8GqbkNMAEemGc_rPAcwCKA" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;time.h>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;  typedef enum EventSource {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource,&#xA;&#x9;&#x9;Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum EventKind {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind,&#xA;&#x9;&#x9;List,&#x9;&#x9;  // Command events&#xA;&#x9;&#x9;Show,&#xA;&#x9;&#x9;Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;double cpuTick;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;long getSeconds() const;&#xA;&#x9;long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;double getCpuTick() const;&#xA;&#x9;void setCpuTick(double tick = 0.0);&#xA;&#x9;static double currentCpuTick();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;  void setField(const std::string field, const std::string value);&#xA;  const std::string getField(const std::string field) const;&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;&#x9;this->setCpuTick();&#xA;  this->setTimestamp(seconds, nanoseconds);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;double Event::getCpuTick() const {&#xA;&#x9;return this->cpuTick;&#xA;}&#xA;&#xA;void Event::setCpuTick(double tick) {&#xA;  if (tick == 0.0)&#xA;    this->cpuTick = currentCpuTick();&#xA;  else&#xA;    this->cpuTick = tick;&#xA;}&#xA;&#xA;double Event::currentCpuTick() {&#xA;  return double(clock());&#xA;}&#xA;&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the fields of the observer&#xA;const std::string Event::getField(const std::string field) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return this->getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return this->getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return this->getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; this->getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; this->getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; this->getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; this->getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;cputick&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; this->getCpuTick();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setField(const std::string field, const std::string value) {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;this->setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;this->setSourceName(value);&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;this->setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;this->setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;this->setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;this->setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;this->setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;cputick&quot;) {&#xA;&#x9;&#x9;this->setCpuTick(atol(value.c_str()));&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_8JDoQdMAEemGc_rPAcwCKA" base_Artifact="_8JDoQNMAEemGc_rPAcwCKA" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string readData() = 0;&#xA;&#x9;virtual void sendData(std::string data) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Method::configure(std::map&lt;std::string, std::string> configList) {&#xA;  (void)configList;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_8JEPUdMAEemGc_rPAcwCKA" base_Artifact="_8JEPUNMAEemGc_rPAcwCKA" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_8JE2YdMAEemGc_rPAcwCKA" base_Artifact="_8JE2YNMAEemGc_rPAcwCKA" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
</xmi:XMI>
