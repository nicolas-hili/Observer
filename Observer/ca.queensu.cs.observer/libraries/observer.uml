<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Package xmi:id="_rqPoENRIEeayFZJ-SYgDzA" name="Observation">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_pg8AwBYIEee3LJqEo64_Eg" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_pg918BYIEee3LJqEo64_Eg" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Package" xmi:id="_TIQtwNRNEearFdKvR_8nWw" name="Observation">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_TIMcUNRNEearFdKvR_8nWw" name="Observation">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_TIVmQNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TITxENRNEearFdKvR_8nWw" contract="_TITxENRNEearFdKvR_8nWw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_TIeJINRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIbF0NRNEearFdKvR_8nWw" contract="_TIbF0NRNEearFdKvR_8nWw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TITxENRNEearFdKvR_8nWw" name="Observation"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TIW0YNRNEearFdKvR_8nWw" name="Observation~">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_di784NRNEearFdKvR_8nWw" name="event">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_XIa7ENROEearFdKvR_8nWw" name="data" type="_hltsEFzUEeevlLbSf8F1Eg"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_TIZ3sNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIW0YNRNEearFdKvR_8nWw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_TIaewNRNEearFdKvR_8nWw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_TIbF0NRNEearFdKvR_8nWw" name="ObservationIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_TIewMNRNEearFdKvR_8nWw" client="_TIMcUNRNEearFdKvR_8nWw" supplier="_TIbF0NRNEearFdKvR_8nWw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_eIzqENRNEearFdKvR_8nWw" operation="_di784NRNEearFdKvR_8nWw"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_7RXxINRMEearFdKvR_8nWw" name="Observer" classifierBehavior="_JWCwUNROEearFdKvR_8nWw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_kLF8oNRNEearFdKvR_8nWw" name="observation" visibility="public" type="_TIMcUNRNEearFdKvR_8nWw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_xnxB8N21EeakB9CQglrL_g" value="20"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_xntXkN21EeakB9CQglrL_g" value="20"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_7_KOwNRNEearFdKvR_8nWw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_JX_00NhDEeaqev0ObzxoAQ" name="commandTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_v6JnQH3fEeeLa6HXnixBwQ" name="eventQueue" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_3fw4UH3gEeeLa6HXnixBwQ" name="eventTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_xfMiYH3zEeeLa6HXnixBwQ" name="isPeriodic">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_7UrZwH3zEeeLa6HXnixBwQ"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_JWCwUNROEearFdKvR_8nWw" name="ObserverStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_JWHo0NROEearFdKvR_8nWw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_JWPkoNROEearFdKvR_8nWw" name="configure" source="_JWJeANROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2mliENgzEeaqev0ObzxoAQ">
              <language>C++</language>
              <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new Socket();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new Text();
this->serializer->configure(config.getConfigList());

std::string mode = config.get(&quot;mode&quot;);
std::string periodicity = config.get(&quot;periodicity&quot;);

// If sending events is set as periodic
if (periodicity != &quot;&quot; &amp;&amp; mode == &quot;periodic&quot;) {
	this->isPeriodic = true;
	// Periodicity is set in microseconds
	// Multiplied by 1000 to get nanoseconds
	long nano = (long long)(atol(periodicity.c_str())*1000);
	long seconds = nano/1000000000;
	eventTimer.informEvery(UMLRTTimespec(seconds, (nano-1000000000*seconds)));
}

// Instantiating the command timer
commandTimer.informEvery(UMLRTTimespec(0,500000000));
</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_RFMNUNROEearFdKvR_8nWw" name="event received" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_elYb4NROEearFdKvR_8nWw">
              <language>C++</language>
              <body>std::string event = this->serializer->serialize(data.event) + &quot;\n&quot;;
if (this->isPeriodic) {
	eventQueue.push_back(event);
}
else {
	this->method->sendData(event);
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_Ur9fsNROEearFdKvR_8nWw" event="_eIzqENRNEearFdKvR_8nWw" port="_kLF8oNRNEearFdKvR_8nWw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_AIf_YNhDEeaqev0ObzxoAQ" name="command received" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WYUQgNhDEeaqev0ObzxoAQ">
              <language>C++</language>
              <body>std::string data = this->method->read();
    if (data != &quot;&quot;) {
    Event evt = this->serializer->parse(data);
    if (evt.getEventSource() == Event::EventSource::Command) {

      std::map&lt;std::string, size_t>::iterator iter;
      std::string sourceName = evt.getSourceName();

      switch(evt.getEventKind()) {
        case Event::EventKind::List:
          // List of capsule parts
          evt.setSourceName(&quot;Observer&quot;);
          for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
            evt.setParam(iter->first, capsuleTypes[iter->first]);
          }
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Show:
          // Show a specific capsule part
          this->method->sendData(this->serializer->serialize(listCapsuleMessage(evt)));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Trigger:
          evt = this->triggerCapsuleMessage(evt);
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        default:
        break;
      }
    }
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_ZnQ4wNhDEeaqev0ObzxoAQ" port="_JX_00NhDEeaqev0ObzxoAQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_rCO0YBYIEee3LJqEo64_Eg" name="register capsules" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_zp5NwBYIEee3LJqEo64_Eg">
              <language>C++</language>
              <body>std::stringstream ss;
ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
printf(&quot;capsule name: %s at port %d\n&quot;, ss.str().c_str(), (int)msg->sapIndex0_);
capsules[ss.str()] = msg->sapIndex0_;
capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_syzaIBYIEee3LJqEo64_Eg" port="_kLF8oNRNEearFdKvR_8nWw">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
            </trigger>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WIZHIH3kEeeLa6HXnixBwQ" name="events periodically sent" source="_JWMhUNROEearFdKvR_8nWw" target="_JWMhUNROEearFdKvR_8nWw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fsEc0H3kEeeLa6HXnixBwQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>unsigned size = this->eventQueue.size();
for (unsigned int i = 0; i &lt; size; i++) {
	this->method->sendData(this->eventQueue.back());
	this->eventQueue.pop_back();
}</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WhnfcH3kEeeLa6HXnixBwQ" port="_3fw4UH3gEeeLa6HXnixBwQ">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_JWJeANROEearFdKvR_8nWw">
            <name xsi:nil="true"/>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_JWMhUNROEearFdKvR_8nWw" name="OBSERVING"/>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_E2OD0KMgEeiNcrjkKG4ksw" name="listCapsuleMessage" specification="_h6x0oKMfEeiNcrjkKG4ksw">
        <language>C++</language>
        <body>/*
 * Return the list of capsule message
 * Below is an example
 * Overriden by the model instrumentation.
std::string sourceName = evt.getSourceName();
if (sourceName == &quot;Gen&quot;) {
        evt.setParam(&quot;1&quot;, &quot;timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;generate&quot;);
}
else if (...) {
}

*/
return evt;
</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_uC5ZYKOVEeiGGIWOIACepw" name="triggerCapsuleMessage" specification="_isFSIKOVEeiGGIWOIACepw">
        <language>C++</language>
        <body>return evt;

/*  
 * The code below is an example of what to generate
std::map&lt;std::string, size_t>::iterator iter;
  std::string instanceName = evt.getCapsuleInstance(); // name of the instance
  std::string capsuleType = &quot;&quot;;     // name of the capsule
  std::string opName    = evt.getParam(&quot;operation&quot;);
  int portIndex = -1;

  for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
    if (iter->first == instanceName) {
      portIndex = capsules[iter->first];
      capsuleType = capsuleTypes[iter->first];
      break;
    }
  }

// For debugging purpose
//  printf(&quot;instanceName = %s, capsuleType = %s, portIndex = %d\n&quot;, 
//      instanceName.c_str(),
//      capsuleType.c_str(),
//      (int)portIndex);

  if (portIndex == -1) {
    printf(&quot;Problem with instanceName = %s\n&quot;, instanceName.c_str());
    evt.setParam(&quot;success&quot;, 0);
    return evt;
  }

  if (capsuleType == &quot;Gen&quot;) {
    if (opName == &quot;timer_timeout&quot;) {
      observation.Gen_timer_timeout().sendAt(portIndex);
      evt.setParam(&quot;success&quot;, 1);
    }
  }
  if (capsuleType == &quot;Chute&quot;) {
    if (opName == &quot;enter_transmit&quot;) {
      observation.Chute_enter_transmit(this->parcel).sendAt(portIndex);
      evt.setParam(&quot;success&quot;, 1);
    }
  }

  evt.setParam(&quot;success&quot;, 0);
  return evt; */</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7A2QAKO1EeiDysg9bce8IQ" name="to_bool" specification="_nMJWcKO1EeiDysg9bce8IQ">
        <language>C++</language>
        <body>return strcmp(s.c_str(),&quot;0&quot;) != 0 &amp;&amp; strcmp(s.c_str(), &quot;false&quot;) != 0;</body>
      </ownedBehavior>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_h6x0oKMfEeiNcrjkKG4ksw" name="listCapsuleMessage" concurrency="guarded" method="_E2OD0KMgEeiNcrjkKG4ksw">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_vc584KMfEeiNcrjkKG4ksw" name="evt">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_9bpvsKMfEeiNcrjkKG4ksw" name="response" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_isFSIKOVEeiGGIWOIACepw" name="triggerCapsuleMessage" concurrency="guarded" method="_uC5ZYKOVEeiGGIWOIACepw">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_ks8WoKOVEeiGGIWOIACepw" name="evt">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_ktDrYKOVEeiGGIWOIACepw" name="response" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
      </ownedOperation>
      <ownedOperation xmi:type="uml:Operation" xmi:id="_nMJWcKO1EeiDysg9bce8IQ" name="to_bool" concurrency="guarded" method="_7A2QAKO1EeiDysg9bce8IQ">
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_x7X5QKO1EeiDysg9bce8IQ" name="s">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:type="uml:Parameter" xmi:id="_3A5BkKO1EeiDysg9bce8IQ" name="result" direction="return">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_YqQ6AN2eEeakB9CQglrL_g" name="internal">
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5gyNoF1QEemYMutb7hxLzQ" name="CLIUtils"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kELIF1QEemYMutb7hxLzQ" name="Socket"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kEyMV1QEemYMutb7hxLzQ" name="Method"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kFZQV1QEemYMutb7hxLzQ" name="SharedMem"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kGAUF1QEemYMutb7hxLzQ" name="Serializer"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kGnYV1QEemYMutb7hxLzQ" name="Text"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kHOcV1QEemYMutb7hxLzQ" name="MQTT"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kH1gV1QEemYMutb7hxLzQ" name="Event"/>
      <packagedElement xmi:type="uml:Artifact" xmi:id="_5kIckV1QEemYMutb7hxLzQ" name="Config"/>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_PUZk4FSTEemSbvLi_UYxQQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_PUdPQFSTEemSbvLi_UYxQQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_TIvqIFScEemmpvdrl88cHg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_TIzUgFScEemmpvdrl88cHg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_5gsuEF1QEemYMutb7hxLzQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_5gvxYF1QEemYMutb7hxLzQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_u3BoQJ9ZEeWtHskdthI1Bg"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="platform:/Development/ca.queensu.cs.observer.update/model/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_hltsEFzUEeevlLbSf8F1Eg" name="EventObj"/>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_rqpQsNRIEeayFZJ-SYgDzA">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_rqrF4NRIEeayFZJ-SYgDzA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_-yPMoNRIEearFdKvR_8nWw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_-ygSYNRIEearFdKvR_8nWw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_-y8-UNRIEearFdKvR_8nWw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_-y9lYNRIEearFdKvR_8nWw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_30kJAH3zEeeLa6HXnixBwQ">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_30kwEH3zEeeLa6HXnixBwQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
    </profileApplication>
  </uml:Package>
  <UMLRealTime:Capsule xmi:id="_7Sjc49RMEearFdKvR_8nWw" base_Class="_7RXxINRMEearFdKvR_8nWw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_TISi8NRNEearFdKvR_8nWw" base_Package="_TIQtwNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIU_MNRNEearFdKvR_8nWw" base_Interface="_TITxENRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIYpkNRNEearFdKvR_8nWw" base_Interface="_TIW0YNRNEearFdKvR_8nWw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_TIc7ANRNEearFdKvR_8nWw" base_Interface="_TIbF0NRNEearFdKvR_8nWw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_TIfXQNRNEearFdKvR_8nWw" base_Collaboration="_TIMcUNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTPort xmi:id="_kLI_8NRNEearFdKvR_8nWw" isNotification="true" isPublish="true" isWired="false" registration="Automatic" base_Port="_kLF8oNRNEearFdKvR_8nWw"/>
  <UMLRealTime:RTPort xmi:id="_7_N5INRNEearFdKvR_8nWw" isWired="false" base_Port="_7_KOwNRNEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_JWL6QNROEearFdKvR_8nWw" base_Pseudostate="_JWJeANROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTState xmi:id="_JWO9kNROEearFdKvR_8nWw" base_State="_JWMhUNROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_JWQLsNROEearFdKvR_8nWw" base_Region="_JWHo0NROEearFdKvR_8nWw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_JXT7oNROEearFdKvR_8nWw" base_StateMachine="_JWCwUNROEearFdKvR_8nWw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_rFjo0NRXEearFdKvR_8nWw" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" base_Class="_7RXxINRMEearFdKvR_8nWw" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_JYIXsNhDEeaqev0ObzxoAQ" isWired="false" base_Port="_JX_00NhDEeaqev0ObzxoAQ"/>
  <RTCppProperties:CapsuleProperties xmi:id="_kesEUFzUEeevlLbSf8F1Eg" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_hltsEFzUEeevlLbSf8F1Eg" publicDeclarations="Event event;"/>
  <RTCppProperties:AttributeProperties xmi:id="__cG5QH3fEeeLa6HXnixBwQ" type="std::deque&lt;std::string>" base_Property="_v6JnQH3fEeeLa6HXnixBwQ"/>
  <UMLRealTime:RTPort xmi:id="_3gClIH3gEeeLa6HXnixBwQ" isPublish="false" isWired="false" base_Port="_3fw4UH3gEeeLa6HXnixBwQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_loF-cKMgEeiNcrjkKG4ksw" type="Event" base_Parameter="_vc584KMfEeiNcrjkKG4ksw"/>
  <RTCppProperties:ParameterProperties xmi:id="_olPFAKMgEeiNcrjkKG4ksw" type="Event" base_Parameter="_9bpvsKMfEeiNcrjkKG4ksw"/>
  <RTCppProperties:ParameterProperties xmi:id="_ktJyAKOVEeiGGIWOIACepw" type="Event" base_Parameter="_ks8WoKOVEeiGGIWOIACepw"/>
  <RTCppProperties:ParameterProperties xmi:id="_ktSU4KOVEeiGGIWOIACepw" type="Event" base_Parameter="_ktDrYKOVEeiGGIWOIACepw"/>
  <RTCppProperties:ParameterProperties xmi:id="_M9DZEKPFEeizIuv3spzswQ" type="std::string" base_Parameter="_x7X5QKO1EeiDysg9bce8IQ"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5j5zEF1QEemYMutb7hxLzQ" base_Artifact="_5gyNoF1QEemYMutb7hxLzQ" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kEyMF1QEemYMutb7hxLzQ" base_Artifact="_5kELIF1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;socket.port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;socket.address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kFZQF1QEemYMutb7hxLzQ" base_Artifact="_5kEyMV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kFZQl1QEemYMutb7hxLzQ" base_Artifact="_5kFZQV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * SharedMem.hh&#xA; *&#xA; *  Created on: Jun 28, 2016&#xA; *      Author: mojtaba&#xA; */&#xA;&#xA;#ifndef SHAREDMEM_H_&#xA;#define SHAREDMEM_H_&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;boost/interprocess/managed_shared_memory.hpp>&#xA;#include &lt;boost/interprocess/allocators/allocator.hpp>&#xA;#include &lt;boost/interprocess/containers/string.hpp>&#xA;#include &lt;boost/interprocess/containers/deque.hpp>&#xA;#include &lt;boost/interprocess/sync/scoped_lock.hpp>&#xA;#include &lt;boost/interprocess/sync/named_mutex.hpp>&#xA;&#xA;using namespace boost::interprocess;&#xA;typedef allocator&lt;char, managed_shared_memory::segment_manager>   CharAllocator;&#xA;typedef basic_string&lt;char, std::char_traits&lt;char>, CharAllocator> ShmString;&#xA;typedef allocator&lt;ShmString, managed_shared_memory::segment_manager> ShmStringAllocator;&#xA;typedef deque&lt;ShmString, ShmStringAllocator> ShmStringDeque;&#xA;////  manage the mode that shared mem will be open&#xA;&#xA;enum Mode {&#xA;  Client,&#xA;  Server&#xA;};&#xA;&#xA;enum Status {&#xA;  Initialized,&#xA;  Ready,&#xA;  Failed&#xA;};&#xA;&#xA;class SharedMem: public Method {&#xA;&#xA;public:&#xA;&#x9;SharedMem();&#xA;&#x9;virtual ~SharedMem();&#xA;&#xA;  virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;  virtual const bool canConnect() const;&#xA;  virtual int connect();&#xA;  virtual void disconnect();&#xA;  virtual std::string read();&#xA;  virtual void sendData(std::string data);&#xA;&#xA;&#x9;const std::string&amp; getName();&#xA;&#x9;const std::string&amp; getNameCmd();&#xA;&#x9;void setName(const std::string&amp; name);&#xA;&#x9;const std::string&amp; getQueueName() const;&#xA;&#x9;const std::string&amp; getQueueNameCmd() const;&#xA;&#x9;void setQueueName(const std::string&amp; queueName);&#xA;&#x9;void pushBackString(std::string data);&#xA;&#x9;void pushBackStringCmd(std::string data);&#xA;&#x9;void safePushBackString(std::string data);&#xA;&#x9;void safePushBackStringCmd(std::string data);&#xA;&#x9;void safePushFrontString(std::string data);&#xA;&#x9;void pushFrontString(std::string data);&#xA;&#x9;std::string popFrontString();&#xA;&#x9;std::string popBackString();&#xA;&#x9;std::string popBackStringCmd();&#xA;&#x9;std::string getData(size_t index=0);&#xA;&#x9;int  getQueueSize();&#xA;&#x9;std::string safePopFrontString();&#xA;&#x9;std::string safePopBackString();&#xA;&#x9;std::string safePopBackStringCmd();&#xA;&#x9;std::string safeGetData(size_t index=0);&#xA;&#x9;int  safeGetQueueSize();&#xA;&#x9;Status getStatus() const;&#xA;&#x9;void setStatus(Status status);&#xA;&#x9;Mode getMode() const;&#xA;&#x9;void setMode(Mode mode);&#xA;&#x9;bool isWithLock() const;&#xA;&#x9;void setWithLock(bool withLock);&#xA;  const size_t getSize() const;&#xA;  void setSize(const size_t size);&#xA;&#xA;private :&#xA;&#x9;std::string name;&#xA;&#x9;std::string nameCmd;&#xA;&#xA;&#x9;ShmStringDeque *sharedDeque;&#xA;&#x9;std::string queueName;&#xA;&#x9;managed_shared_memory observerSegment;&#xA;&#xA;&#x9;ShmStringDeque *sharedDequeCmd;&#xA;&#x9;std::string queueNameCmd;&#xA;&#x9;//managed_shared_memory observerSegmentCmd;&#xA;&#xA;&#x9;bool withLock;&#xA;&#x9;Status status;&#xA;&#x9;Mode mode;&#xA;&#x9;named_mutex * areaMutex;&#xA;&#x9;named_mutex * areaMutexCmd;&#xA;&#x9;size_t size;&#xA;};&#xA;&#xA;#endif /* SHAREDMEM_H_ */" sourceFile="/*&#xA; * SharedMem.cc&#xA; *&#xA; *  Created on: Jun 28, 2016&#xA; *      Author: mojtaba&#xA; */&#xA;&#xA;#include &quot;SharedMem.hh&quot;&#xA;#include &lt;boost/lexical_cast.hpp>&#xA;#include &lt;boost/interprocess/managed_shared_memory.hpp>&#xA;#include &lt;boost/interprocess/allocators/allocator.hpp>&#xA;#include &lt;boost/interprocess/containers/string.hpp>&#xA;#include &lt;boost/interprocess/containers/deque.hpp>&#xA;#include &lt;boost/interprocess/sync/scoped_lock.hpp>&#xA;#include &lt;boost/interprocess/sync/named_mutex.hpp>&#xA;&#xA;using namespace boost::interprocess;&#xA;&#xA;SharedMem::SharedMem() : Method() {&#xA;&#xA;&#x9;sharedDeque=0;&#xA;&#x9;sharedDequeCmd=0;&#xA;&#xA;&#x9;areaMutex=0;&#xA;&#x9;areaMutexCmd=0;&#xA;&#xA;&#x9;this->setName(&quot;EventArea&quot;);&#xA;&#x9;this->setQueueName(&quot;EventQ&quot;);&#xA;&#x9;this->setSize(9999999);&#xA;&#x9;this->setWithLock(true);&#xA;&#x9;this->setStatus(Status::Initialized);&#xA;  this->setMode(Mode::Server);&#xA;}&#xA;&#xA;SharedMem::~SharedMem() {&#xA;&#x9;if (this->getMode() == Mode::Server) {&#xA;    shared_memory_object::remove(this->name.c_str());&#xA;    shared_memory_object::remove(this->nameCmd.c_str());&#xA;  }&#xA;}&#xA;&#xA;void SharedMem::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;  std::string name, qName, withLock, size, mode;&#xA;&#xA;  name      = this->getConfig(configList, &quot;sharedmem.name&quot;);&#xA;  qName     = this->getConfig(configList, &quot;sharedmem.qName&quot;);&#xA;  withLock  = this->getConfig(configList, &quot;sharedmem.withLock&quot;);&#xA;  size      = this->getConfig(configList, &quot;sharedmem.size&quot;);&#xA;  mode      = this->getConfig(configList, &quot;sharedmem.mode&quot;);&#xA;&#xA;  if (!name.empty())&#xA;    this->setName(name);&#xA;&#xA;  if (!qName.empty())&#xA;    this->setQueueName(qName);&#xA;&#xA;  if (!withLock.empty())&#xA;    this->setWithLock(boost::lexical_cast&lt;bool>(withLock));&#xA;&#xA;  if (!size.empty())&#xA;    this->setSize(atoi(size.c_str()));&#xA;&#xA;  if (!mode.empty())&#xA;    this->setMode(static_cast&lt;Mode>(atoi(mode.c_str())));&#xA;&#xA;  printf(&quot;name: %s, qName: %s, size: %d, withLock: %d\n&quot;,&#xA;      this->getName().c_str(),&#xA;      this->getQueueName().c_str(),&#xA;      (int)this->getSize(),&#xA;      this->isWithLock());&#xA;}&#xA;&#xA;const bool SharedMem::canConnect() const {&#xA;  return true;&#xA;}&#xA;&#xA;int SharedMem::connect() {&#xA;&#xA;&#x9;if (this->getMode() == Mode::Server) {&#xA;&#xA;&#x9;&#x9;try {&#xA;      // Remove it if it is already created before&#xA;&#x9;&#x9;&#x9;shared_memory_object::remove(this->getName().c_str());&#xA;&#x9;&#x9;&#x9;//shared_memory_object::remove(this->getNameCmd().c_str());&#xA;&#xA;&#x9;&#x9;&#x9;this->observerSegment = managed_shared_memory(create_only,&#xA;                                                    this->getName().c_str(),&#xA;                                                    this->getSize());&#xA;&#xA;&#x9;&#x9;&#x9;//this->observerSegmentCmd = managed_shared_memory(create_only,&#xA;      //                                              this->getNameCmd().c_str(),&#xA;      //                                              this->getSize());&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;&#x9;&#x9;const ShmStringAllocator stringInst(observerSegment.get_segment_manager());&#xA;&#xA;&#x9;&#x9;&#x9;//const CharAllocator charallocatorCmd (observerSegmentCmd.get_segment_manager());&#xA;&#x9;&#x9;&#x9;//const ShmStringAllocator stringInstCmd(observerSegmentCmd.get_segment_manager());&#xA;&#xA;&#x9;&#x9;&#x9;this->sharedDeque = observerSegment.construct&lt;ShmStringDeque>(this->getQueueName().c_str())(stringInst);&#xA;&#x9;&#x9;&#x9;this->sharedDequeCmd = observerSegment.construct&lt;ShmStringDeque>(this->getQueueNameCmd().c_str())(stringInst);&#xA;&#x9;&#x9;&#x9;//this->sharedDequeCmd = observerSegmentCmd.construct&lt;ShmStringDeque>(this->getQueueNameCmd().c_str())(stringInstCmd);&#xA;&#xA;&#x9;&#x9;&#x9;// Create the mutex also for locking&#xA;&#x9;&#x9;&#x9;named_mutex::remove((this->getName()).c_str());&#xA;&#x9;&#x9;&#x9;named_mutex::remove((this->getNameCmd()).c_str());&#xA;&#xA;&#x9;&#x9;&#x9;this->areaMutex    = new named_mutex(create_only, (this->getName()).c_str());&#xA;&#x9;&#x9;&#x9;this->areaMutexCmd = new named_mutex(create_only, (this->getNameCmd()).c_str());&#xA;&#x9;&#x9;&#x9;this->setStatus(Status::Ready);&#xA;&#x9;&#x9;&#x9;return 0;&#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;catch(boost::interprocess::interprocess_exception &amp;ex) {&#xA;      printf(&quot;The Error happened in  shared memory setup:\n&quot;);&#xA;      this->setStatus(Status::Failed);&#xA;      return -1;&#xA;&#x9;&#x9;}&#xA;  }&#xA;&#x9;if (this->getMode() == Mode::Client) {&#xA;&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;this->observerSegment=managed_shared_memory(open_only, this->getName().c_str());&#xA;&#x9;&#x9;&#x9;//this->observerSegmentCmd=managed_shared_memory(open_only, this->getNameCmd().c_str());&#xA;&#x9;&#x9;&#x9;// find and load related queue&#xA;&#x9;&#x9;&#x9;this->sharedDeque = observerSegment.find&lt;ShmStringDeque>(this->getQueueName().c_str()).first;&#xA;&#x9;&#x9;&#x9;this->sharedDequeCmd = observerSegment.find&lt;ShmStringDeque>(this->getQueueNameCmd().c_str()).first;&#xA;&#x9;&#x9;&#x9;//this->sharedDeque = segment.find&lt;ShmStringVector>(&quot;MyVector&quot;).first;&#xA;&#x9;&#x9;&#x9;this->setStatus(Status::Ready);&#xA;&#x9;&#x9;&#x9;// Create the mutex&#xA;&#x9;&#x9;&#x9;this->areaMutex = new named_mutex(open_only, (this->getName()).c_str());&#xA;&#x9;&#x9;&#x9;this->areaMutexCmd = new named_mutex(open_only, (this->getNameCmd()).c_str());&#xA;&#x9;&#x9;&#x9;return 0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;catch (boost::interprocess::interprocess_exception &amp;ex) {&#xA;&#x9;&#x9;&#x9;printf(&quot;The Error happened in  shared memory setup:\n&quot;);&#xA;&#x9;&#x9;&#x9;this->setStatus(Status::Failed);&#xA;&#x9;&#x9;&#x9;return -1;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;// no other mode exists now, will be extended in the future&#xA;&#x9;&#x9;return -1;&#xA;  }&#xA;&#xA;  return -1;&#xA;}&#xA;&#xA;void SharedMem::disconnect() {&#xA;  // nothing here for now&#xA;}&#xA;&#xA;&#xA;std::string SharedMem::read() {&#xA;&#x9;if (this->getMode() == Mode::Server) {&#xA;    return safePopBackStringCmd();&#xA;  }&#xA;  else if (this->getMode() == Mode::Client) {&#xA;    return safePopBackString();&#xA;  }&#xA;  return &quot;&quot;;&#xA;}&#xA;&#xA;void SharedMem::sendData(std::string data) {&#xA;&#x9;if (this->getMode() == Mode::Server) {&#xA;    safePushBackString(data);&#xA;  }&#xA;  else if (this->getMode() == Mode::Client) {&#xA;    safePushBackStringCmd(data);&#xA;  }&#xA;}&#xA;&#xA;const std::string&amp; SharedMem::getName() {&#xA;&#x9;&#x9;return this->name;&#xA;}&#xA;&#xA;const std::string&amp; SharedMem::getNameCmd() {&#xA;&#x9;&#x9;return this->nameCmd;&#xA;}&#xA;&#xA;void SharedMem::setName(const std::string&amp; name) {&#xA;&#x9;this->name = name;&#xA;&#x9;this->nameCmd = name + &quot;Cmd&quot;;&#xA;}&#xA;&#xA;const size_t SharedMem::getSize() const {&#xA;  return this->size;&#xA;}&#xA;&#xA;void SharedMem::setSize(const size_t size) {&#xA;  this->size = size;&#xA;}&#xA;&#xA;const std::string&amp; SharedMem::getQueueName() const {&#xA;&#x9;return queueName;&#xA;}&#xA;&#xA;const std::string&amp; SharedMem::getQueueNameCmd() const {&#xA;&#x9;return queueNameCmd;&#xA;}&#xA;&#xA;void SharedMem::setQueueName(const std::string&amp; queueName) {&#xA;&#x9;this->queueName = queueName;&#xA;&#x9;this->queueNameCmd = queueName + &quot;Cmd&quot;;&#xA;}&#xA;&#xA;Status SharedMem::getStatus() const {&#xA;&#x9;return status;&#xA;}&#xA;&#xA;void SharedMem::setStatus(Status status) {&#xA;&#x9;this->status = status;&#xA;}&#xA;&#xA;Mode SharedMem::getMode() const {&#xA;&#x9;return mode;&#xA;}&#xA;&#xA;void SharedMem::setMode(Mode mode) {&#xA;&#x9;this->mode = mode;&#xA;}&#xA;&#xA;bool SharedMem::isWithLock() const {&#xA;&#x9;return withLock;&#xA;}&#xA;&#xA;void SharedMem::setWithLock(bool withLock) {&#xA;&#x9;this->withLock = withLock;&#xA;}&#xA;&#xA;std::string SharedMem::popFrontString() {&#xA;&#xA;&#x9;if (!this->sharedDeque->empty()) {&#xA;&#x9;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;&#x9;ShmString tempString(charallocator);&#xA;&#x9;&#x9;tempString= this->sharedDeque->front();&#xA;&#x9;&#x9;this->sharedDeque->pop_front();&#xA;&#x9;&#x9;return std::string(tempString.begin(),tempString.end());&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::popBackString() {&#xA;&#xA;&#x9;if (!this->sharedDeque->empty()) {&#xA;&#x9;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;&#x9;ShmString tempString(charallocator);&#xA;&#x9;&#x9;tempString=this->sharedDeque->back();&#xA;&#x9;&#x9;this->sharedDeque->pop_back();&#xA;&#x9;&#x9;return std::string(tempString.begin(),tempString.end());&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::popBackStringCmd() {&#xA;&#xA;&#x9;if (!this->sharedDequeCmd->empty()) {&#xA;&#x9;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;&#x9;ShmString tempStringCmd(charallocator);&#xA;&#x9;&#x9;tempStringCmd=this->sharedDequeCmd->back();&#xA;&#x9;&#x9;this->sharedDequeCmd->pop_back();&#xA;&#x9;&#x9;return std::string(tempStringCmd.begin(),tempStringCmd.end());&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::getData(size_t index) {&#xA;&#xA;&#x9;if(this->sharedDeque->size() > index) {&#xA;    const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;    ShmString tempString(charallocator);&#xA;    tempString=this->sharedDeque->at(index);&#xA;    return std::string(tempString.begin(),tempString.end());&#xA;&#x9;}&#xA;&#x9;else {&#xA;    return &quot;&quot;;&#xA;  }&#xA;}&#xA;&#xA;int SharedMem::safeGetQueueSize() {&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;  return this->sharedDeque->size();&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::safePopFrontString() {&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;  return this->popFrontString();&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::safePopBackString()&#xA;{&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;  return this->popBackString();&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::safePopBackStringCmd()&#xA;{&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutexCmd);&#xA;&#x9;  return this->popBackStringCmd();&#xA;  }&#xA;}&#xA;&#xA;std::string SharedMem::safeGetData(size_t index)&#xA;{&#xA;&#x9;{scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;return this->getData(index);}&#xA;}&#xA;&#xA;int SharedMem::getQueueSize() {&#xA;  return this->sharedDeque->size();&#xA;}&#xA;&#xA;void SharedMem::pushBackString(std::string data) {&#xA;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;ShmString tempString(charallocator);&#xA;&#x9;tempString = data.c_str();&#xA;&#x9;this->sharedDeque->push_back(tempString);&#xA;}&#xA;&#xA;void SharedMem::safePushFrontString(std::string data) {&#xA;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;ShmString tempString(charallocator);&#xA;&#x9;tempString=data.c_str();&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;  this->sharedDeque->push_back(tempString);&#xA;  }&#xA;}&#xA;&#xA;void SharedMem::pushFrontString(std::string data) {&#xA;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;ShmString tempString(charallocator);&#xA;&#x9;tempString=data.c_str();&#xA;&#x9;this->sharedDeque->push_front(tempString);&#xA;}&#xA;&#xA;void SharedMem::safePushBackString(std::string data) {&#xA;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;ShmString tempString(charallocator);&#xA;&#x9;tempString=data.c_str();&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutex);&#xA;&#x9;  this->sharedDeque->push_front(tempString);&#xA;  }&#xA;}&#xA;&#xA;void SharedMem::safePushBackStringCmd(std::string data) {&#xA;&#x9;const CharAllocator charallocator (observerSegment.get_segment_manager());&#xA;&#x9;//const CharAllocator charallocatorcmd (observerSegmentCmd.get_segment_manager());&#xA;&#x9;ShmString tempStringCmd(charallocator);&#xA;&#x9;tempStringCmd=data.c_str();&#xA;&#x9;{&#xA;    scoped_lock&lt;named_mutex> lock(*areaMutexCmd);&#xA;&#x9;  this->sharedDequeCmd->push_front(tempStringCmd);&#xA;  }&#xA;}&#xA;&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kGnYF1QEemYMutb7hxLzQ" base_Artifact="_5kGAUF1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kHOcF1QEemYMutb7hxLzQ" base_Artifact="_5kGnYV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|capsuleInstance|eventSource|eventKind|seconds|nanoseconds|cpuTick|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;cputick&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getCpuTick();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;event.setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;cputick&quot;) {&#xA;&#x9;&#x9;event.setCpuTick(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kH1gF1QEemYMutb7hxLzQ" base_Artifact="_5kHOcV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * MQTT.hh&#xA; *&#xA; *  Created on: Mar 21, 2019&#xA; *      Author: karim&#xA; */&#xA;&#xA;#ifndef MQTT_HH_&#xA;#define MQTT_HH_&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &lt;queue>&#xA;#include &lt;MQTTClient.h>&#xA;&#xA;class MQTT: public Method {&#xA;&#xA;private:&#xA;&#x9;std::string port;&#xA;&#x9;std::string address;&#xA;&#x9;std::string username;&#xA;&#x9;std::string password;&#xA;&#x9;std::string subTopic;&#xA;&#x9;std::string pubTopic;&#xA;&#x9;MQTTClient * client;&#xA;&#xA;&#x9;std::string getTopic(std::string data);&#xA;&#xA;&#x9;static std::queue&lt;std::string> inQueue;&#xA;&#x9;static char * generateClientID ( const int len );&#xA;&#x9;static int messageReceived ( void * context, char * topicName, int topicLen, MQTTClient_message * message );&#xA;&#xA;public:&#xA;&#x9;MQTT();&#xA;&#x9;virtual ~MQTT();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const std::string getPort() const;&#xA;&#x9;void setPort(const std::string port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;&#xA;&#x9;const std::string getUsername() const;&#xA;&#x9;void setUsername(const std::string username);&#xA;&#xA;&#x9;const std::string getPassword() const;&#xA;&#x9;void setPassword(const std::string password);&#xA;&#xA;&#x9;const std::string getPubTopic() const;&#xA;&#x9;void setPubTopic(const std::string pubTopic);&#xA;&#xA;&#x9;const std::string getSubTopic() const;&#xA;&#x9;void setSubTopic(const std::string subTopic);&#xA;&#xA;};&#xA;&#xA;#endif /* MQTT_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;MQTT.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sstream>&#xA;#include &lt;math.h>&#xA;#include &lt;iterator>&#xA;#include &lt;regex>&#xA;&#xA;std::queue&lt;std::string> MQTT::inQueue;&#xA;&#xA;char * MQTT::generateClientID ( const int len ) {&#xA;    struct timespec ts;&#xA;    clock_gettime(CLOCK_MONOTONIC, &amp;ts);&#xA;    srand((time_t)ts.tv_nsec);&#xA;&#xA;&#x9;char* s = (char*) malloc(sizeof(char) * len);&#xA;    if(s == NULL)&#xA;        return NULL;&#xA;&#xA;    static const char alphanum[] =&#xA;        &quot;0123456789&quot;&#xA;        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&#xA;        &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#xA;&#xA;    for (int i = 0; i &lt; len; ++i) {&#xA;        s[i] = alphanum[rand() % (sizeof(alphanum) - 1)];&#xA;    }&#xA;&#xA;    s[len] = 0;&#xA;&#x9;return s;&#xA;}&#xA;&#xA;&#xA;int MQTT::messageReceived ( void * context, char * topicName, int topicLen, MQTTClient_message * message )&#xA;{&#xA;&#x9;std::string msgStr((const char*)message->payload);&#xA;&#x9;inQueue.push(msgStr);&#xA;&#x9;MQTTClient_free(topicName);&#xA;&#x9;MQTTClient_freeMessage(&amp;message);&#xA;&#x9;return 1;&#xA;}&#xA;&#xA;MQTT::MQTT() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->client = NULL;&#xA;&#x9;this->setPort(&quot;1883&quot;);&#xA;&#x9;this->setAddress(&quot;mqtt.jahed.ca&quot;);&#xA;&#x9;this->setUsername(&quot;&quot;);&#xA;&#x9;this->setPassword(&quot;&quot;);&#xA;&#x9;this->setPubTopic(&quot;observer_out&quot;);&#xA;&#x9;this->setSubTopic(&quot;observer_in&quot;);&#xA;}&#xA;&#xA;MQTT::~MQTT() {&#xA;}&#xA;&#xA;void MQTT::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address, username, password, subTopic, pubTopic;&#xA;&#x9;port = this->getConfig(configList, &quot;mqtt.port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;mqtt.address&quot;);&#xA;&#x9;username = this->getConfig(configList, &quot;mqtt.username&quot;);&#xA;&#x9;password = this->getConfig(configList, &quot;mqtt.password&quot;);&#xA;&#x9;subTopic = this->getConfig(configList, &quot;mqtt.subTopic&quot;);&#xA;&#x9;pubTopic = this->getConfig(configList, &quot;mqtt.pubTopic&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(port);&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;if (!username.empty())&#xA;&#x9;&#x9;this->setUsername(username);&#xA;&#xA;&#x9;if (!password.empty())&#xA;&#x9;&#x9;this->setPassword(password);&#xA;&#xA;&#x9;if (!subTopic.empty())&#xA;&#x9;&#x9;this->setSubTopic(subTopic);&#xA;&#xA;&#x9;if (!pubTopic.empty())&#xA;&#x9;&#x9;this->setPubTopic(pubTopic);&#xA;}&#xA;&#xA;const bool MQTT::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int MQTT::connect () {&#xA;&#x9;std::string uri(&quot;tcp://&quot;);&#xA;&#x9;uri.append(address);&#xA;&#x9;uri.append(&quot;:&quot;);&#xA;&#x9;uri.append(port);&#xA;&#xA;&#x9;printf(&quot;MQTT uri: %s\n&quot;, uri.c_str());&#xA;&#xA;&#x9;client = new MQTTClient;&#xA;&#x9;MQTTClient_create(client, uri.c_str(), generateClientID(16), MQTTCLIENT_PERSISTENCE_NONE, NULL);&#xA;&#x9;MQTTClient_setCallbacks(*client, NULL , NULL, messageReceived, NULL);&#xA;&#xA;&#x9;MQTTClient_connectOptions connOpts = MQTTClient_connectOptions_initializer;&#xA;&#x9;connOpts.keepAliveInterval = 20;&#xA;&#x9;connOpts.cleansession = 1;&#xA;&#xA;&#x9;if(!username.empty() &amp;&amp; !password.empty()) {&#xA;&#x9;&#x9;connOpts.username = username.c_str();&#xA;&#x9;&#x9;connOpts.password = password.c_str();&#xA;&#x9;}&#xA;&#xA;&#x9;int ret = MQTTClient_connect(*client, &amp;connOpts);&#xA;&#x9;ret &amp;= MQTTClient_subscribe(*client, subTopic.c_str(), 0);&#xA;&#x9;return ret == MQTTCLIENT_SUCCESS;&#xA;}&#xA;&#xA;void MQTT::disconnect()&#xA;{&#xA;&#x9;if( client != NULL ) {&#xA;&#x9;&#x9;MQTTClient_disconnect(*client, 1000);&#xA;&#x9;&#x9;MQTTClient_destroy(client);&#xA;&#x9;&#x9;client = NULL;&#xA;&#x9;}&#xA;}&#xA;&#xA;std::string MQTT::read() {&#xA;&#x9;if(!inQueue.empty()) {&#xA;&#x9;&#x9;std::string msg = inQueue.front();&#xA;&#x9;&#x9;inQueue.pop();&#xA;&#x9;&#x9;return msg;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;std::string MQTT::getTopic(std::string data) {&#xA;&#x9;//[FIXME] support different data pattern&#xA;&#x9;static std::regex splitter(&quot;\\|&quot;);&#xA;&#x9;std::vector&lt;std::string> tokens;&#xA;&#xA;&#x9;std::copy( std::sregex_token_iterator(data.begin(), data.end(), splitter, -1),&#xA;&#x9;&#x9;&#x9;  std::sregex_token_iterator(),&#xA;&#x9;&#x9;&#x9;  std::back_inserter(tokens));&#xA;&#xA;&#x9;std::string stateName = tokens[1];&#xA;&#x9;std::string capsuleFQN = tokens[2];&#xA;&#x9;std::replace(capsuleFQN.begin(), capsuleFQN.end(), '.', '/');&#xA;&#x9;return pubTopic + std::string(&quot;/&quot;) + capsuleFQN + std::string(&quot;/&quot;) + stateName;&#xA;}&#xA;&#xA;void MQTT::sendData(std::string data) {&#xA;&#x9;if(client != NULL)&#xA;&#x9;&#x9;MQTTClient_publish(*client, getTopic(data).c_str(), data.length(), data.c_str(), 0, 0, NULL);&#xA;}&#xA;&#xA;const std::string MQTT::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void MQTT::setPort(const std::string port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string MQTT::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void MQTT::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}&#xA;&#xA;const std::string MQTT::getUsername() const {&#xA;&#x9;return this->username;&#xA;}&#xA;&#xA;void MQTT::setUsername(const std::string username) {&#xA;&#x9;this->username = username;&#xA;}&#xA;&#xA;const std::string MQTT::getPassword() const {&#xA;&#x9;return this->password;&#xA;}&#xA;&#xA;void MQTT::setPassword(const std::string password) {&#xA;&#x9;this->password = password;&#xA;}&#xA;&#xA;const std::string MQTT::getPubTopic() const {&#xA;&#x9;return this->pubTopic;&#xA;}&#xA;&#xA;void MQTT::setPubTopic(const std::string pubTopic) {&#xA;&#x9;this->pubTopic = pubTopic;&#xA;}&#xA;&#xA;const std::string MQTT::getSubTopic() const {&#xA;&#x9;return this->subTopic;&#xA;}&#xA;&#xA;void MQTT::setSubTopic(const std::string subTopic) {&#xA;&#x9;this->subTopic = subTopic;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kIckF1QEemYMutb7hxLzQ" base_Artifact="_5kH1gV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;time.h>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource,&#xA;&#x9;&#x9;Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind,&#xA;&#x9;&#x9;List,&#x9;&#x9;  // Command events&#xA;&#x9;&#x9;Show,&#xA;&#x9;&#x9;Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;double cpuTick;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const double getCpuTick() const;&#xA;&#x9;void setCpuTick(double tick = 0.0);&#xA;&#x9;static double currentCpuTick();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;&#x9;this->setCpuTick();&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const double Event::getCpuTick() const {&#xA;&#x9;return this->cpuTick;&#xA;}&#xA;&#xA;void Event::setCpuTick(double tick) {&#xA;  if (tick == 0.0)&#xA;    this->cpuTick = currentCpuTick();&#xA;  else&#xA;    this->cpuTick = tick;&#xA;}&#xA;&#xA;double Event::currentCpuTick() {&#xA;  return double(clock());&#xA;}&#xA;&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_5kJDoF1QEemYMutb7hxLzQ" base_Artifact="_5kIckV1QEemYMutb7hxLzQ" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*******************************************************************************&#xA; * Copyright (c) 2016-2017 School of Computing -- Queen's University&#xA; *&#xA; * All rights reserved. This program and the accompanying materials&#xA; * are made available under the terms of the Eclipse Public License v1.0&#xA; * which accompanies this distribution, and is available at&#xA; * http://www.eclipse.org/legal/epl-v10.html&#xA; *&#xA; * Contributors:&#xA; *     Mojtaba Bagherzadeh &lt;mojtaba@cs.queensu.ca>&#xA; *     Nicolas Hili &lt;hili@cs.queensu.ca>&#xA; ******************************************************************************/&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
</xmi:XMI>
